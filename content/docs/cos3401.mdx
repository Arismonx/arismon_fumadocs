---
title: image processing
description: หมวดที่ 1 การปรับปรุงคุณภาพของภาพ
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

## งานชุดที่ 1
#### ข้อที่ 1 
นักศึกษาต้องประยุกต์ใช้อัลกอริธึมที่เหมาะสมในการปรับปรุงคุณภาพของภาพหลอดเลือดหัวใจ (Image
Enhancement for Intravascular Ultrasound: IVUS) โดยมีข้อกําหนดดังต่อไปนี้
   - การปรับปรุงเพื่อแสดงองค์ประกอบของชั้นแอดเวนทิเชีย (Adventitia) เท่านั้น
      นักศึกษาต้องปรับปรุงภาพเพื่อให้สามารถแสดงองค์ประกอบของชั้นแอดเวนทิเชีย ซึ่งเป็นชั้นเนื้อเยื่อ
      เกี่ยวพันที่แข็งที่สุดในโครงสร้างของหลอดเลือด โดยแสดงเป็นบริเวณที่มีความสว่างมากที่สุดในภาพ และ
      ปรากฏในลักษณะของวงแหวนที่ปกคลุมรอบหลอดเลือด
   - การปรับปรุงองค์ประกอบของเนื้อเยื่อหลอดเลือดที่ไม่สมบูรณ์และลดผลกระทบจากเงาของภาพ
      นักศึกษาต้องดําเนินการปรับปรุงคุณภาพของภาพเพื่อลดความไม่สมบูรณ์และความไม่ต่อเนื่องของเนื้อเยื่อ
      หลอดเลือด ซึ่งอาจเกิดจากผลกระทบของเงาภาพ (Shadow Artifacts) โดยต้องทําให้โครงสร้างของหลอด
      เลือดมีความสมบูรณ์มากขึ้น และลดผลกระทบจากเงาของภาพให้น้อยที่สุด

      ![Test](/image/frame_ivus.png)
    
    
<Accordions type="single">
  <Accordion title="คำตอบ ข้อที่ 1">
    มี 2 ข้อย่อย 1.1 กับ 1.2

    ```py
import numpy as np
import cv2
import matplotlib.pyplot as plt

def plt_show_image(img):
        plt.axis("off")
        plt.imshow(img, cmap='gray')
        plt.show()

def cv_show(img,title=''):
        cv2.imshow(title, img)
        cv2.waitKey(0)
        cv2.destroyAllWindows()

def normalize(img):
        img_norm = img.astype(np.float16)
        img_norm = img_norm/np.amax(img_norm)
        return img_norm

def power_gamma(gamma,img_norm,c=255.0):
        gamma_img = (img_norm**gamma)*c
        gamma_img = gamma_img.astype(np.uint8)
        return gamma_img

def main():
        img = cv2.imread("./image/frame_ivus.png",0)
   
        #1.1
        img_norm = normalize(img) # ทำ normalize
        gamma1_img = power_gamma(0.5,img_norm) #มาคำนวน power gamma ให้ภาพสว่างมากขึ้น
        #plt_show_image(gamma1_img)
        cv2.imwrite('./out/frame_ivus_1.png', gamma1_img)
   
        concat = cv2.hconcat([img,gamma1_img])
        cv_show(concat)
   
        #1.2
        gamma2_img = power_gamma(4.0,img_norm) #มาคำนวน power gamma มืดลง ลดเงา
        #plt_show_image(gamma2_img)
        cv2.imwrite('./out/frame_ivus_2.png', gamma2_img)
   
        concat = cv2.hconcat([img,gamma2_img])
        cv_show(concat)

if __name__ == '__main__':
        main()
    ```

    รูปคำตอบข้อ 1.1
    ![1.1](/image/frame_ivus_1.png)

    รูปคำตอบข้อ 1.2
    ![1.1](/image/frame_ivus_2.png)
  </Accordion>
</Accordions>

#### ข้อที่ 2
ให้นักศึกษาเขียนโปรแกรมเพื่อค้นหาขอบภาพที่สมบูรณ์และชัดเจนที่สุด จากสองภาพที่กําหนด โดยภาพ
แรกมีระดับความสว่างต่ํา และภาพที่สองมีระดับความสว่างสูง
![2.1](/image/dark_image.png)
![2.1](/image/bright_image.png)

<Accordions type="single">
  <Accordion title="คำตอบ ข้อที่ 2">
    มี 2 ข้อย่อย 2.1 กับ 2.2

    ```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def plt_show_image(img):
        plt.axis("off")
        plt.imshow(img, cmap='gray')
        plt.show()

def cv_show(img,title=''):
        cv2.imshow(title, img)
        cv2.waitKey(0)
        cv2.destroyAllWindows()

def edge_operator_meth(img, k):
        f = img.copy().astype(np.float16)
        out = np.zeros_like(img, dtype = 'float16')
        mask_gx = np.array([[-1, 0, 1], [-k, 0, k], [-1, 0, 1]] , dtype = 'float16') 
        mask_gy = np.array([[-1, -k, -1], [0, 0, 0], [1, k, 1]] , dtype = 'float16') 
 
        sz, sz = mask_gx.shape
        bd = sz // 2
        (m,n) = f.shape
        for i in range(bd,m-bd):
            for j in range(bd,n-bd):
                gx, gy = 0., 0.
                sub_f = f[i - bd : i + bd + 1, j - bd : j + bd + 1]
                gx = np.multiply(sub_f, mask_gx).sum() 
                gy = np.multiply(sub_f, mask_gy).sum()    
                out[i,j] = np.sqrt(gx**2 + gy**2)
        out[out>255.0] = 255.0
        return out.astype(np.uint8)

def normalize(img):
        img_norm = img.astype(np.float16)
        img_norm = img_norm/np.amax(img_norm)
        return img_norm

def power_gamma(gamma,img_norm,c=255.0):
        gamma_img = (img_norm**gamma)*c
        gamma_img = gamma_img.astype(np.uint8)
        return gamma_img 

def cdf(gamma_img):
        hist, _ = np.histogram(gamma_img.flatten(), 256, [0,256])
        cdf = hist.cumsum()
        cdf_m = np.ma.masked_equal(cdf, 0) 
        cdf_m = ((cdf_m - cdf_m.min())  / (cdf_m.max() - cdf_m.min()))*255
        cdf_m = np.ma.filled(cdf_m, 0).astype('uint8')
        equalized_image = cdf_m[gamma_img]
        return equalized_image

def process(fp,opt):
        img = cv2.imread(fp,0)
        img_norm = normalize(img)
        if opt :
            gamma1_img = power_gamma(0.5,img_norm)
        else:
            gamma1_img = power_gamma(5,img_norm)
    
        equalized_image = cdf(gamma1_img)
        img_edge = edge_operator_meth(equalized_image,2)
        return img_edge

def main():
        #2.1
        img_dark = process("./image/dark_image.png",1)
        cv_show(img_dark)
        # cv2.imwrite('./out/dark_image_1.png',img_dark)
    
        #2.2
        img_bright = process("./image/bright_image.png",0)
        cv_show(img_bright)
        # cv2.imwrite('./out/bright_image_1.png',img_bright)

if __name__ == '__main__':
        main()

    ```
    รูปคำตอบข้อ 2.1
    ![2.1](/image/dark_image_1.png)

    รูปคำตอบข้อ 2.2
    ![2.1](/image/bright_image_1.png)
  </Accordion>
</Accordions>

#### ข้อที่ 3
ให้นักศึกษาออกแบบโปรแกรมสําหรับสร้างภาพเอกสารไบนารี (ตัวอักษรสีดําบนพื้นหลังสีขาว) จากไฟล์
ภาพเอกสารที่กําหนด
    - ข้อแนะนํา: ควรแบ่งภาพออกเป็น 4 ส่วน และ พิจารณาใช้วิธีการกําหนดค่าเธรชโฮลด์แบบ Inter- mean หรือ Otsu นอกจากนี้ ควรดําเนินการกําจัด
        pepper noise ในบางบริเวณเพื่อให้ได้ผลลัพธ์ที่มี
        คุณภาพสูงขึ้น
    ![3.1](/image/document1.png)

    - ข้อแนะนํา: ควรแบ่งภาพออกเป็นมากกว่า 4 ส่วน เพื่อให้ได้ผลลัพธ์ที่มีคุณภาพดีที่สุดเท่าที่เป็นไปได้
    ![3.2](/image/document2.jpg)

<Accordions type="single">
  <Accordion title="คำตอบ ข้อที่ 3">
    มี 2 ข้อย่อย 3.1 กับ 3.2

    ```py
import numpy as np
import cv2
import matplotlib.pyplot as plt
import math

def plt_show_image(img):
        plt.axis("off")
        plt.imshow(img, cmap='gray')
        plt.show()

def show_histogram(hist):
        plt.plot(hist)
        plt.show()

def cv_show(img,title=''):
        cv2.imshow(title, img)
        cv2.waitKey(0)
        cv2.destroyAllWindows()

def split_image(img):
        _ , width = img.shape
        width_cutoff = width // 2
        left = img[:, :width_cutoff]
        right = img[:, width_cutoff:]
        return left, right

def Hist_image(img):
        row, col = img.shape
        hist = [0.0] * 256
        for i in range(row):
            for j in range(col):
                hist[img[i, j]]+=1
        return np.array(hist)

def intermean(hist, t):
        prob = hist/np.sum(hist)
    
        w0 = np.sum(prob[:t]) + 0.00000001
        w1 = np.sum(prob[t:]) + 0.00000001
    
        u0 = np.sum(np.array([i for i in range(t)])*prob[:t])/w0
        u1 = np.sum(np.array([i for i in range(t,256)])*prob[t:])/w1
        if (u0 == 0.0):
            thr = u1
        elif (u1 == 0.0):
            thr = u0
        else:
            thr = (u0 +u1) / 2

        return thr.astype('int16')

def otsu(hist,img):
        T0 = int(np.mean(img))
        flag = True
        Tlist = []
        Tlist.append(T0)
        while (flag):
            T1 = intermean(hist, T0)
            Tlist.append(T1)
            if (math.fabs(T1 -T0) < 1):
                flag = False
            else:
                T0 = T1
        T = Tlist[-1]
        return T

def document_image_1():
        img = cv2.imread("./image/document1.png",0)
    
        #แบ่งรูปเป็น 2 ส่วน ซ้ายกับขวา
        sub_left, sub_right = split_image(img)
    
        #ต้องการแบ่งรูปของทั้ง 2 ส่วนเลยต้องหมุนรูปทวนเข็มให้เป็นแนวนอนทั้ง รูปซ้าย และ ขวา
        sub_left = cv2.rotate(sub_left, cv2.ROTATE_90_COUNTERCLOCKWISE)
        sub_right = cv2.rotate(sub_right, cv2.ROTATE_90_COUNTERCLOCKWISE)
    
        #หลังจากหมุนรูปแล้ว ก็จะแบ่งให้เป็นอีก 2 ส่วนทั้ง ซ้ายและขวา 
        # ตอนนี้จะมีทั้งหมด 4 รูป คือ รูปบนซ้าย ล่างซ้าย บนขวา ล่างขวา
        sub_left_1, sub_left_2 = split_image(sub_left)
        sub_right_1, sub_right_2 = split_image(sub_right)
    
        #หลังจากแบ่งเป็น 4 รูปย่อยแล้ว ก็หมุนตามเข็มรูปจะกลับมาเป็นรูปเดิม
        sub_left_1 = cv2.rotate(sub_left_1, cv2.ROTATE_90_CLOCKWISE)
        sub_left_2 = cv2.rotate(sub_left_2, cv2.ROTATE_90_CLOCKWISE)
        sub_right_1 = cv2.rotate(sub_right_1, cv2.ROTATE_90_CLOCKWISE)
        sub_right_2= cv2.rotate(sub_right_2, cv2.ROTATE_90_CLOCKWISE)
    
        #แก้ไขรูปที่ sub_left_1
        #ดู histogram
        hist = Hist_image(sub_left_1)
    
        #สร้าง array ที่เหมือนกับ sub_left_1 โดยค่าใน array ทั้งหมดเป็น 0
        new_sub_left_1 = np.zeros_like(sub_left_1)
    
        #หาค่า thresholding จาก function otsu
        thresh_sub_left_1 = otsu(hist,sub_left_1)
    
        #เป็นหน้ากากที่เทียบค่าทุก pixel ของ sub_left_1 ถ้ามีค่ามากกว่า thresh_sub_left_1 จะเปลี่ยนเป็นสีขาวคือ255
        new_sub_left_1[sub_left_1 >= thresh_sub_left_1] = 255
    
        #แปลงให้เป็น uint8
        new_sub_left_1 = new_sub_left_1.astype(np.uint8)
    
        #update sub_left_1
        sub_left_1 = new_sub_left_1
    
        #แก้ไขรูปที่ sub_left_2
        #ดู histogram ว่า thresholding ควรอยู่ตรงไหน
        hist = Hist_image(sub_left_2)
    
        #สร้าง array ที่เหมือนกับ sub_left_2 โดยค่าใน array ทั้งหมดเป็น 0
        new_sub_left_2 = np.zeros_like(sub_left_2)
   
        #เป็นหน้ากากที่เทียบค่าทุก pixel ของ sub_left_2 ถ้ามีค่ามากกว่า 240 จะเปลี่ยนเป็นสี ขาวคือ 255
        new_sub_left_2[sub_left_2 >= 240] = 255 
    
        #แปลงเป็น uint8 และ เอา 255 - จะเปลี่ยนจากสีขาวเป็นสีดำคือส่วนตรงอักษร PY และ update sub_left_2
        sub_left_2 = 255 - new_sub_left_2.astype(np.uint8)
    
        #แก้ไขรูปที่ sub_right_1
        #ดู histogram ว่า thresholding ควรอยู่ตรงไหน
        hist = Hist_image(sub_right_1)
    
        #สร้าง array ที่เหมือนกับ sub_right_1 โดยค่าใน array ทั้งหมดเป็น 0
        new_sub_right_1 = np.zeros_like(sub_right_1)
    
        #ค่า Thresholding ที่ได้จากการดู histogram
        thresh = 150
    
        #เป็นหน้ากากที่เทียบค่าทุก pixel ของ sub_left_2 ถ้ามีค่ามากกว่า 150 จะเปลี่ยนเป็นสี ขาวคือ 255
        new_sub_right_1[sub_right_1 >= thresh] = 255
    
        #แปลงเป็น uint8 และ เอา 255 - จะเปลี่ยนจากสีขาวเป็นสีดำคือส่วนตรงอักษร DE FG และ update sub_right_1
        sub_right_1 = 255 - new_sub_right_1.astype(np.uint8)

        #แก้ไขรูปที่ sub_right_2
        #ดู histogram ว่า thresholding ควรอยู่ตรงไหน
        hist = Hist_image(sub_right_2)
    
        #ใช้ cv2.medianBlur ลด noise
        sub_right_2 = cv2.medianBlur(sub_right_2, 5)
    
        #สร้าง array ที่เหมือนกับ sub_right_2 โดยค่าใน array ทั้งหมดเป็น 0
        new_sub_right_2 = np.zeros_like(sub_right_2)
    
        #หาค่า thresholding จาก function otsu
        thresh = otsu(hist,sub_right_2)
    
        #เป็นหน้ากากที่เทียบค่าทุก pixel ของ sub_left_2 ถ้ามีค่ามากกว่า thresh จะเปลี่ยนเป็นสี ขาวคือ 255
        new_sub_right_2[sub_right_2 >= thresh] = 255
    
        #แปลงเป็น uint8 และ  update sub_right_2
        sub_right_2 = new_sub_right_2.astype(np.uint8)
    
        #Concat รวมรูปภาพย่อย 4 รูปเป็น 1 รูป
        sub_left = cv2.vconcat([sub_left_1, sub_left_2])
        sub_right = cv2.vconcat([sub_right_1, sub_right_2])
        complete_img = cv2.hconcat([sub_left, sub_right])
    
        cv2.imwrite('./out/document1_1.png', complete_img)
        cv_show(complete_img)

def document_image_2():
        img = cv2.imread("./image/document2.jpg",0)
    
        sub_left, sub_right = split_image(img)
    
        sub_left = cv2.rotate(sub_left, cv2.ROTATE_90_COUNTERCLOCKWISE)
        sub_right = cv2.rotate(sub_right, cv2.ROTATE_90_COUNTERCLOCKWISE)
    
        sub_left_1, sub_left_2 = split_image(sub_left)
        sub_right_1, sub_right_2 = split_image(sub_right)
    
        sub_left_1 = cv2.rotate(sub_left_1, cv2.ROTATE_90_CLOCKWISE)
        sub_left_2 = cv2.rotate(sub_left_2, cv2.ROTATE_90_CLOCKWISE)
        sub_right_1 = cv2.rotate(sub_right_1, cv2.ROTATE_90_CLOCKWISE)
        sub_right_2= cv2.rotate(sub_right_2, cv2.ROTATE_90_CLOCKWISE)
    
        # sub_left_1
        hist = Hist_image(sub_left_1)
        new_sub_left_1 = np.zeros_like(sub_left_1)
        thresh = otsu(hist,sub_left_1)
        new_sub_left_1[sub_left_1 >= thresh] = 255
        sub_left_1 = new_sub_left_1.astype(np.uint8)

    
        # sub_left_2
        sub_left_2_1 = cv2.rotate(sub_left_2, cv2.ROTATE_90_COUNTERCLOCKWISE)
    
        sub_left_2_1_1, sub_left_2_1_2 = split_image(sub_left_2_1)
    
        sub_left_2_1_1 = cv2.rotate(sub_left_2_1_1, cv2.ROTATE_90_CLOCKWISE)
        sub_left_2_1_2 = cv2.rotate(sub_left_2_1_2, cv2.ROTATE_90_CLOCKWISE)
    
        hist = Hist_image(sub_left_2_1_1)
        new_sub_left_2_1_1 = np.zeros_like(sub_left_2_1_1)
        thresh = otsu(hist,sub_left_2_1_1)
        new_sub_left_2_1_1[sub_left_2_1_1 >= thresh] = 255
        sub_left_2_1_1 = new_sub_left_2_1_1.astype(np.uint8)

        # hist = Hist_image(sub_left_2_1_2)
        # show_histogram(hist)
        new_sub_left_2_1_2 = np.zeros_like(sub_left_2_1_2)
        thresh = 95
        new_sub_left_2_1_2[sub_left_2_1_2 >= thresh] = 255
        sub_left_2_1_2 = new_sub_left_2_1_2.astype(np.uint8)
        
        sub_left_2 = cv2.vconcat([sub_left_2_1_1, sub_left_2_1_2])
        
        # sub_right_1
        r_sub_right_1 = cv2.rotate(sub_right_1, cv2.ROTATE_90_COUNTERCLOCKWISE)
        sub_right_1_1, sub_right_1_2 = split_image(r_sub_right_1)
        
        sub_right_1_1 = cv2.rotate(sub_right_1_1, cv2.ROTATE_90_CLOCKWISE)
        sub_right_1_2 = cv2.rotate(sub_right_1_2, cv2.ROTATE_90_CLOCKWISE)

        # sub_right_1_1
        sub_right_1_1_1, sub_right_1_1_2 = split_image(sub_right_1_1)
        
        # hist = Hist_image(sub_right_1_1_1)
        # show_histogram(hist)
        new_sub_right_1_1_1 = np.zeros_like(sub_right_1_1_1)
        thresh = 95
        new_sub_right_1_1_1[sub_right_1_1_1 >= thresh] = 255
        sub_right_1_1_1 = new_sub_right_1_1_1.astype(np.uint8)
        
        hist = Hist_image(sub_right_1_1_2)
        new_sub_right_1_1_2 = np.zeros_like(sub_right_1_1_2)
        thresh = otsu(hist,sub_right_1_1_2)
        new_sub_right_1_1_2[sub_right_1_1_2 >= thresh] = 255
        sub_right_1_1_2 = new_sub_right_1_1_2.astype(np.uint8)
        
        sub_right_1_1 = cv2.hconcat([sub_right_1_1_1, sub_right_1_1_2])

        # sub_right_1_2
        sub_right_1_2_1, sub_right_1_2_2 = split_image(sub_right_1_2)
        
        # hist = Hist_image(sub_right_1_2_1)
        # show_histogram(hist)
        new_sub_right_1_2_1 = np.zeros_like(sub_right_1_2_1)
        thresh = 95
        new_sub_right_1_2_1[sub_right_1_2_1 >= thresh] = 255
        sub_right_1_2_1 = new_sub_right_1_2_1.astype(np.uint8)
        
        hist = Hist_image(sub_right_1_2_2)
        new_sub_right_1_2_2 = np.zeros_like(sub_right_1_2_2)
        thresh = otsu(hist,sub_right_1_2_2)
        new_sub_right_1_2_2[sub_right_1_2_2 >= thresh] = 255
        sub_right_1_2_2 = new_sub_right_1_2_2.astype(np.uint8)
        
        sub_right_1_2 = cv2.hconcat([sub_right_1_2_1, sub_right_1_2_2])
        
        sub_right_1 = cv2.vconcat([sub_right_1_1, sub_right_1_2])
        
        # sub_right_2
        # sub_right_2_1
        r_sub_right_2 = cv2.rotate(sub_right_2, cv2.ROTATE_90_COUNTERCLOCKWISE)
        sub_right_2_1, sub_right_2_2 = split_image(r_sub_right_2)
        
        sub_right_2_1 = cv2.rotate(sub_right_2_1, cv2.ROTATE_90_CLOCKWISE)
        sub_right_2_2 = cv2.rotate(sub_right_2_2, cv2.ROTATE_90_CLOCKWISE)

        # sub_right_2_1_1
        sub_right_2_1_1, sub_right_2_1_2 = split_image(sub_right_2_1)
        
        # hist = Hist_image(sub_right_2_1_1)
        # show_histogram(hist)
        new_sub_right_2_1_1 = np.zeros_like(sub_right_2_1_1)
        thresh = 90
        new_sub_right_2_1_1[sub_right_2_1_1 >= thresh] = 255
        sub_right_2_1_1 = new_sub_right_2_1_1.astype(np.uint8)
        
        # sub_right_2_1_2
        r_sub_right_2_1 = cv2.rotate(sub_right_2_1_2, cv2.ROTATE_90_COUNTERCLOCKWISE)
        sub_right_2_2_1, sub_right_2_2_2 = split_image(r_sub_right_2_1)

        sub_right_2_2_1 = cv2.rotate(sub_right_2_2_1, cv2.ROTATE_90_CLOCKWISE)
        sub_right_2_2_2 = cv2.rotate(sub_right_2_2_2, cv2.ROTATE_90_CLOCKWISE)
        
        hist = Hist_image(sub_right_2_2_1)
        new_sub_right_2_2_1 = np.zeros_like(sub_right_2_2_1)
        thresh = otsu(hist,sub_right_2_2_1)
        new_sub_right_2_2_1[sub_right_2_2_1 >= thresh] = 255
        sub_right_2_2_1 = new_sub_right_2_2_1.astype(np.uint8)
        
        # hist = Hist_image(sub_right_2_2_2)
        # show_histogram(hist)
        new_sub_right_2_2_2 = np.zeros_like(sub_right_2_2_2)
        thresh = 100
        new_sub_right_2_2_2[sub_right_2_2_2 >= thresh] = 255
        sub_right_2_2_2 = new_sub_right_2_2_2.astype(np.uint8)
        
        sub_right_2_1_2 = cv2.vconcat([sub_right_2_2_1, sub_right_2_2_2])
        
        sub_right_2_1 = cv2.hconcat([sub_right_2_1_1, sub_right_2_1_2])

        # sub_right_2_2
        
        # hist = Hist_image(sub_right_2_2)
        # show_histogram(hist)
        new_sub_right_2_2 = np.zeros_like(sub_right_2_2)
        thresh = 80
        new_sub_right_2_2[sub_right_2_2 >= thresh] = 255
        sub_right_2_2 = new_sub_right_2_2.astype(np.uint8)
        
        sub_right_2 = cv2.vconcat([sub_right_2_1, sub_right_2_2])
        
        left = cv2.vconcat([sub_left_1, sub_left_2])
        right = cv2.vconcat([sub_right_1, sub_right_2])
        complete_img = cv2.hconcat([left, right])
        
        cv2.imwrite('./out/document2_1.png', complete_img)
        cv_show(complete_img)

def main():
        document_image_1()
        document_image_2()

if __name__ == '__main__':
        main()
    ```
    รูปคำตอบข้อ 3.1
    ![3.1](/image/document1_1.png)

    รูปคำตอบข้อ 3.2
    ![3.2](/image/document2_1.png)
  </Accordion>
</Accordions>

#### ข้อที่ 4
ให้นักศึกษาดําเนินการสร้างภาพไบนารีขาวดํา โดยกําหนดให้พิกเซลที่มีองค์ประกอบของสีม่วง (ได้แก่
ม่วงแดงและม่วงน้ําเงิน) เป็นพิกเซลสีดํา เช่นเดียวกับพื้นหลัง ขณะที่พิกเซลที่มีช่วงสีตั้งแต่แดงถึงเขียวให้
กําหนดเป็นพิกเซลสีขาวในภาพผลลัพธ์ทั้งนี้ ให้นักศึกษาดําเนินการประมวลผลในทั้งสองระบบสี ได้แก่
`HSV` และ `CMYK` พร้อมทั้งเปรียบเทียบผลลัพธ์ที่ได้

![4](/image/shade.png)

<Accordions type="single">
  <Accordion title="คำตอบ ข้อที่ 4">

    มีคำตอบ `CMYK` `HSV` `CONCAT`

    ```py
import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_image(img,gray):
        plt.axis("off")
        if gray:
            plt.imshow(img, cmap='gray')
        else:
            plt.imshow(img)
        plt.show()

def rgb_to_cmyk(image):
        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        rgb_normalized = rgb_image / 255.0
        
        R = rgb_normalized[:, :, 0]
        G = rgb_normalized[:, :, 1]
        B = rgb_normalized[:, :, 2]

        # Calculate the CMY values
        C = 1 - R
        M = 1 - G
        Y = 1 - B
        
        K = np.minimum(np.minimum(C, M), Y)
        
        denominator = 1 - K
        denominator[denominator == 0] = 1  
        
        C = (C - K) / denominator
        M = (M - K) / denominator
        Y = (Y - K) / denominator
        
        CMYK_image = (np.dstack((C, M, Y, K)) * 255).astype(np.uint8)
        
        return CMYK_image

def Hist_image(img):
        row, col = img.shape
        hist = [0.0] * 256
        for i in range(row):
            for j in range(col):
                
                hist[img[i, j]]+=1
        return np.array(hist)

def show_histogram(hist):
        plt.plot(hist)
        plt.show()

def cmyk():
        img = cv2.imread("./image/shade.png")
        img_cmyk = rgb_to_cmyk(img)
        c = img_cmyk[:,:,2]
        
        # hist = Hist_image(c)
        # show_histogram(hist)
        img1 = np.zeros_like(c, dtype=np.uint8)
        
        #threading 150
        img1[c >= 150] = 255
        # show_image(img1,True)
        # cv2.imwrite('./out/shade_cmyk.png', img1)
        return img1

def hsv():
        img_rgb = cv2.imread("./image/shade.png")
        img_hsv = cv2.cvtColor(img_rgb,cv2.COLOR_BGR2HSV)
        
        #red to green 0 - 90
        lower_red_to_green = np.array([0, 100, 100])
        upper_red_to_green = np.array([90, 255, 255])
        mask1 = cv2.inRange(img_hsv, lower_red_to_green, upper_red_to_green)
        
        # red 170 - 180
        lower_red = np.array([170, 100, 100])
        upper_red = np.array([180, 255, 255])
        mask2 = cv2.inRange(img_hsv, lower_red, upper_red)
        
        img2 = cv2.bitwise_or(mask1, mask2)
        
        # show_image(img2,True)
        # cv2.imwrite('./out/shade_hsv.png', img2)
        return img2

def main():
        img1 = cmyk()
        img2 = hsv()
        show_image(img1,1)
        show_image(img2,1)
        final_img = cv2.hconcat([img1,img2])
        show_image(final_img,1)
        cv2.imwrite('./out/concat_cmyk_hsv.png',final_img)

if __name__ == '__main__':
        main()

    ```
    CMYK
    ![4.1](/image/shade_cmyk.png)

    HSV
    ![4.2](/image/shade_hsv.png)

    CMYK AND HSV
    ![4.3](/image/concat_cmyk_hsv.png)
  </Accordion>
</Accordions>

#### ข้อที่ 5
ให้นักศึกษาดําเนินการลดความอิ่มตัวของสีของภาพที่กําหนดให้ โดยมีขั้นตอนดังนี้
    - แปลงภาพจากระบบสี RGB เป็นระบบสี HSV
    - ลดค่าความอิ่มตัวของสี (Saturation - S) ในภาพ HSV
    - แปลงภาพกลับเป็นระบบสี RGB หรือ BGR
    - บันทึกภาพผลลัพธ์

<Accordions type="single">
  <Accordion title="คำตอบ ข้อที่ 5">

    มีคำตอบ original and reduce saturation 

    ```py
import cv2
import numpy as np

def reduce_saturation(img_hsv,percent):
        img_hsv = img_hsv.astype(np.float32)
        # (h: 0, s: 1, v: 2)
        img_hsv[:, :, 1] *= percent
        return img_hsv.astype(np.uint8)

def cv_show(img,title=''):
        cv2.imshow(title, img)
        cv2.waitKey(0)
        cv2.destroyAllWindows()
    
def main():
        img_bgr = cv2.imread("./image/shade.png",1)
        img_rgb = cv2.cvtColor(img_bgr,cv2.COLOR_BGR2RGB)
        
        #แปลงภาพจากระบบสี RGB เป็นระบบสี HSV
        img_hsv = cv2.cvtColor(img_rgb,cv2.COLOR_BGR2HSV)
        
        #ลดค่าความอิ่มตัวของสี (Saturation - S) ในภาพ HSV
        reduce_saturation_img = reduce_saturation(img_hsv,0.5)
        
        #แปลงภาพกลับเป็นระบบสี RGB หรือ BGR
        new_img_bgr = cv2.cvtColor(reduce_saturation_img,cv2.COLOR_HSV2BGR)
        
        #บันทึกภาพผลลัพธ์
        img_concat = cv2.hconcat([img_bgr,new_img_bgr])
        cv2.imwrite('./out/final_img.png',img_bgr)
        cv2.imwrite('./out/new_img_bgr.png',new_img_bgr)
        cv2.imwrite('./out/final_img_concat.png',img_concat)
        cv_show(img_concat)

if __name__ == '__main__':
        main()

    ```
    original and reduce saturation
    ![5](/image/final_img_concat.png)
  </Accordion>
</Accordions>